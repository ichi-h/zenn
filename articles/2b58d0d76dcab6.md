---
title: "弊社エンジニア全員で『リーダブルコード』を読み直し、「俺たちの理解しやすいコード」を改めて考えてみた"
emoji: "🏫"
publication_name: "wizleap_tech"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["初心者", "Web"]
published: false
---

## はじめに - 本稿の目的

**『リーダブルコード』** といえば、プログラミングをやったことのある人であれば一度は耳にしたことがあったり、また読んだことのある人も多いのではないでしょうか。

この本ではアーキテクチャやデザインパターンといったコードの設計面ではなく、例えば変数名やコメントアウトといった、プログラミングの基本的なお作法と呼ばれるようなもののアプローチから、 **「理解しやすいコード」「読みやすいコード」「優れたコード」とはどういったものなのか** を考察しています。

弊社では、エンジニアほぼ全員参加のリーダブルコード読書会を開き、プログラミングの基礎・基本を改めて学び直しました。  
またそれだけではなく、自分たちでリーダブルコードを発展させていき、「理解しやすいコード」を再定義できるように議論しました。  
本稿ではその議論で挙がった、 **「命名」「コメントアウト」「制御フロー」「変数」「単一責任原則」** の5つの視点から「理解しやすいコードとは何か」を考察します。

もちろん、普遍的に理解しやすいコードは存在せず、チームやプロジェクトによって異なります。  
今回はあくまで「俺たちにとっての理解しやすいコードはこういうものじゃね？」という議論の結果をお話いたします。  
また、リーダブルコードを参考にしておりますが、その解説記事ではございませんので、その点はご承知おきください。

## 命名

### 結論

- **目的を明確に把握できる命名は理解しやすい。**
- **適切に設計されたコードは、理解しやすい命名を生み出す。**

### 目的が明確に把握できる命名

バックエンドで何かしらのUseCaseのクラスを作成する場合、私たちのプロジェクトでは基本的に動詞+目的語を含めるというルールで命名を行っています。  
例えば、システムにユーザーを招待する機能があった場合は以下のようになります。

```php
// InviteUserUseCase.php

class InviteUserUseCase // 動詞: Invite, 目的語: User
{
    public function __construct(
      UserInvitationRepository $userInvitationRepository,
    ) {
    }

    public function handle(User $inviter, Email $inviteeEmail)
    {
        // ユーザーを招待する処理
    }
}
```

なぜこのようにしているのかというと、UseCaseとは端的に言えばアプリケーションとしての1つの機能であり、そして変更する頻度が高い項目になりやすいため、

- 解決する対象は何か
- なにをしてその問題を解決するか

を明確にし、そのUseCaseが **何を目的としたクラスなのかを命名から1発で把握できるようにしておきたい** のです。

### 共通の特徴がある層に属するクラスは命名しやすい

UseCaseのように何かしらの層があるということは、基本的にその層の中に何か共通の役割や特徴を持ったクラスがそこに集められています。  
なので、その共通部分に着目すれば命名に規則性やルールを持たせやすくなります。

定めたルールに乗っかれば、一定の命名の品質を保証でき、またルールがレビューの基準にもなりますので、主観的なコードの良し悪しの判断を減らすことができます。

命名についてアレコレと頭を悩ませるのではなく、**ルールを設けて不要な思考を制限する** ことで、レビュアー・レビュイー双方が効率的に作業を進めることができます。

### 命名が難しい場面

しかし、常に命名が順調にいくわけではありません。

例えば1つのクラスで複数の振る舞いを外側に公開するようなクラスの命名は比較的難しいといえます。  
というのも、それらの振る舞いが矛盾なく自然に説明できるような命名をつけるのは、正直なところ、実装者のセンスに依る部分が大きくなるからですね。

こうした、良い命名を付けにくい場面に遭遇した場合はどうすれば良いのでしょうか？

### 優れた設計が良い命名を生み出す

こうした場合は発想を変えます。

**「そもそも、命名しにくいコードを書いているのが問題なんじゃないか……？」**

例えば、先のようなクラスに対しては、そもそも複数の振る舞いを持つようなクラスが適切なのかと、根本のクラス設計から疑います。

**おおよそ命名が苦しいときは、そのコードの目的が何かを明確に定義付けできないときです。**

- そのクラスによってどんな問題が解決されるのか？
- 何が実現されるのか？

そうした目的ベースでクラスを設計していくことで、自然と命名しやすいコードになっていくと考えます。

理解しやすい命名を考えるのではなく、**各コードの目的を明確にできる優れた設計から理解しやすい命名が生まれてくる** のです。

## コメント

### 結論

- **ドメインに紐づくコメントは、コードの理解を助ける。**

（執筆中）

## 制御フロー

### 結論

- **ネストが浅いコードは理解しやすい。**

（執筆中）

## 変数

### 結論

- **変数のスコープは狭いほうが理解しやすい。**
- **変数を極力使わないコードは理解しやすい。**

### スコープが広い変数の弊害

スコープが広い変数は、コードのありとあらゆる場所で参照される可能性があります。  
その最たる例が「グローバル変数」なのですが、なぜそうしたコードがよくないのかを改めて考えてみましょう。

#### 1. いつ、どこで変更されているかがわからない

様々なところから参照されるので、どのコードから変更が加えられているのかを把握するのが困難なケースがあります。  
これを把握するためには、その変数を参照しているコードをすべて辿っていき、どのタイミングで変更されているかを把握する必要があります。

#### 2. どの範囲まで影響が及ぶのかがわからない

いたるところでその変数に依存するため、その変数を変更したときにどこまでの範囲に影響が及ぶのかを把握するのが難しくなります。  
先の2番の例のように、全く関係のない場所でバグを引き起こしてしまうことが容易に起こり得てしまいます。

### スコープは狭いほうがいい

グローバル変数は非常に便利なものですが、その便利すぎるがゆえに、上記のような弊害が生まれてしまいます。  
なので、変数を使う場合はスコープを狭く持つようにしましょう。

……。

……というのが一般的なグローバル変数の解説なのですが、これだと面白くないので、ここから一歩踏み込み、**そもそも変数自体が理解しにくいコードを生み出す原因になり得る** ということを考えてみましょう。

### 変数と副作用

副作用とは簡単にいえば、**関数を実行したときに、計算処理以外に何らかの影響が出る状態** を表す言葉です。

例えば以下のような関数があったとします。

```ts
let a = 0;
const add = () => {
  a++;
  return a;
};
```

この関数 `add` は、実行するたびに `a` がインクリメントされ、その計算結果が返却されます。

注目したいのは `a++;` の処理です。  
この処理は関数の外にある変数 `a` を参照しており、この処理が実行されるたびに `a` の値は書き換わってしまいます。  
つまりこの関数は、 **実行するたびに関数の外にある状態に影響を与えている** ので、**副作用のある関数** と言うことができます。

こうした副作用を持つ関数の何が問題なのかと言いますと、**関数の実行時に、その処理とは関係のないところに影響を出る可能性がある** ということです。  
先のグローバル変数の例に「いつ変更されるかがわからない」といったものがございましたが、これはまさに副作用があるからこそ起こる問題です。

副作用マシマシなコードとは、一言で言えば **何が起こるかわからないコード** とも言えます。  
安全でバグなくわかりやすいコードを書きたいのに、エンジニア自身が把握できないコードがプロジェクトに眠っている状態というのは、まさに恐怖です。  
そのため、なんとかしてこの副作用と付き合っていく必要があるわけですね。

### 変数を極力使わない

1つの付き合い方として、 **変数を使わない** というものがあります。  
そもそも、変数があるから副作用が起こるわけですので、その原因である **変数を使わなければ副作用を抑えることができます。**

もちろん、変数を使ったほうがシンプルに表現できるケースも存在します。  
なので、（オチとしては面白くもなんともありませんが）変数を使うか使わないかは、副作用を許容したとしても人間にとって理解しやすいコードだと確信を持って言えるときに使うようにしたいですね。

## 単一責任原則

### 結論

- **単一責任原則に則ったコードは理解しやすい。**

（執筆中）
