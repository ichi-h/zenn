---
title: "エンジニア1年目に知っておきたかった、理解しやすいコードの指針"
emoji: "🏫"
publication_name: "wizleap_tech"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["初心者", "Web"]
published: false
---

## はじめに - 本稿の目的・対象者

本稿では **「命名」「コメントアウト」「制御フロー」「変数」「単一責任原則」** という5つの視点から「理解しやすいコードとは何か」を解析します。

読者として、初めてエンジニアとして働くといった駆け出しエンジニアの方を主に想定しています。  
基礎・基本というものは非常に重要で、「砂上の楼閣」という言葉の通り、基礎がなければ上には何も積み上げることができません。  
今回の内容を通して、良いコードとは何かを考える1つの指針として活用していただければ幸いです。

## 命名

### 結論

- **目的を明確に把握できる命名は理解しやすい。**
- **適切に設計されたコードは、理解しやすい命名を生み出す。**

### 目的が明確に把握できる命名

バックエンドで何かしらのUseCaseのクラスを作成する場合、自分たちのプロジェクトでは必ず動詞+目的語を含めるというルールで命名を行っています。

例えば、システムにユーザーを招待するという機能があったとした場合は、

```php
// InviteUserUseCase.php

class InviteUserUseCase // 動詞: Invite, 目的語: User
{
    public function __construct(
      InviteUserDTO $inviteUserDTO,
      UserInvitationRepository $userInvitationRepository,
    ) {
    }

    public function handle(User $inviter, Email $inviteeEmail)
    {
        // ユーザーを招待する処理
    }
}
```

このようにクラス名に動詞と目的語を含め、外部に公開するメソッドをコンストラクタと `handle` メソッドのみにしています。

このようにしている理由は、UseCaseとは端的に言えばアプリケーションとしての1つの機能であり、そして変更する頻度が高い項目であるので、

- 解決する対象は何か
- なにをしてその問題を解決するか

を明確にし、そのUseCaseが **何を目的としたクラスなのかを命名から1発で把握できるようにしたい** という意図があります。

### 共通の特徴がある層に属するクラスの命名はやりやすい

UseCaseのように何かしらの層があるということは、基本的にその層の中に何かしらの共通の役割や特徴を持ったクラスがそこに集められています。  
なので、その共通部分に着目すれば命名に規則性・ルールを持たせやすくなります。

ルールというのは言い換えれば **秩序** で、そのルールに乗っかれば一定ラインの命名の品質を保証してくれます。  
また、ルールがあればレビューの基準にもなりますので、主観的なコードの良し悪しの判断を減らすことができます。

命名についてアレコレと頭を悩ませるのではなく、**ルールを設けて不要な思考を制限する** ことで、レビュアー・レビュイー双方が効率的に作業を進めることができます。

### 命名のルール付けが難しいクラス

しかし、常に命名がルールに乗っかれるとは限りません。

例えばある層が、**他の層の役割に合致せず、溢れたものを拾う受け皿的な層** であった場合はどうでしょうか。  
それは例えばUtilityやServiceといった、言ってしまえば「なんでも入ってしまうディレクトリ」がそれに該当します。  
こうした層の場合、各クラスに本質的な繋がりがあるわけではないので、良い命名の基準となるようなルールを構築することが困難です。

またさらに、例えば何かしらのリソースに対してCRUD操作を行えるような、**1つのクラスで複数の振る舞いを外側に公開するようなクラスの命名** も難しいといえます。  
それらの振る舞いをすべて説明できるような命名ができれば良いですが、これもルールや法則があるわけではないので、常に良い命名ができるとは限りません。

こうした、ルールで解決しにくいクラスの命名はどうすれば良いのでしょうか？

### 優れた設計が良い命名を生み出す

こうした場合は発想を変えます。

**「そもそも、命名しにくいコードを書いているのが問題なんじゃないか……？」**

UtilityやServiceにクラスを追加する前に、そのクラスをそこに置くべきなのか、他に適切な置き場はないのか、そもそもクラスとして切って良いのかなど、そうした設計面を疑います。

また、複数の振る舞いを持つようなクラスに対しては、そもそも複数の振る舞いを持つようなクラスが適切なのかと、根本のクラス設計から疑います。

**おおよそ命名が苦しいときは、そのコードの目的が何かを明確に定義付けできないときです。**

- そのクラスによってどんな問題が解決されるのか？
- 何が実現されるのか？

そうした目的ベースでクラスを設計していくことで、自然と命名しやすいコードになっていくと考えます。

理解しやすい命名を考えるのではなく、**各コードの目的が明確化される優れた設計から理解しやすい命名が生まれてくる** のです。

## コメント

### 結論

- **ドメインに紐づくコメントは、コードの理解を助ける。**

（執筆中）

## 制御フロー

### 結論

- **ネストが浅いコードは理解しやすい。**

（執筆中）

## 変数

### 結論

- **変数のスコープは狭いほうが理解しやすい。**
- **変数を極力使わないコードは理解しやすい。**

### スコープが広い変数の弊害

スコープが広い変数というのは、コードのありとあらゆるところで参照されている可能性があることを意味します。  
その最たる例が「グローバル変数」なわけなのですが、なぜそうしたコードがよくないのかを改めて考えてみましょう。

#### 1. どこで変更されているかがわからない

様々なところから参照されているので、どのコードから変更が加えられているのかを把握するのが困難なケースがあります。  
これを把握するためには、その変数を参照しているコードをすべて辿っていき、どのタイミングで変更されているかを把握する必要があります。

#### 2. いつ変更されるかがわからない

どこからでも変更可能な変数ですので、何らかの処理でその変数を使っているときに、全く別の場所から変更が入り、処理の途中で値が変わり、処理がおかしくなってしまった、ということも考えられます。  
この場合、その処理単体で見たときに間違いはないわけですので、このバグの発見は非常に困難と言えるでしょう。

#### 3. どの範囲まで影響が及ぶのかがわからない

いたるところでその変数に依存するため、その変数を変更したときにどこまでの範囲に影響が及ぶのかを把握するのが難しくなります。  
先の2番の例のように、全く関係のない場所でバグを引き起こしてしまうということが容易に起こり得てしまいます。

### スコープは狭いほうがいい

グローバル変数というのは非常に便利なものですが、その便利すぎるがゆえに、上記のような弊害が生まれてしまいます。  
なので、変数を使う場合はスコープを狭く持つようにしましょう。

……。

……というのが一般的なグローバル変数の解説なのですが、ここからさらに一歩踏み込み、**そもそも変数自体がバグを生み出す原因になる** ということを考えてみましょう。

### 変数と副作用

副作用というのは簡単にいえば、**関数を実行したときに、計算処理以外に影響を与えていない** 状態を表す言葉です。

例えば以下のような関数があったとします。

```ts
let a = 0;
const add = () => {
  a++;
  return a;
};
```

この関数 `add` は、関数を実行するたびに `a` がインクリメントされ、その値が返されます。

注目したいのは `a++;` という処理です。  
この処理は関数の外にある変数 `a` を参照しており、この処理が実行されるたびに `a` の値は書き換わってしまいます。  
つまり、**この関数は実行するたびに関数の外にある変数の状態に影響を与えている** ので、**副作用のある関数** と言うことができます。

こうした副作用を持つ関数の何が問題なのかと言いますと、**関数の実行時に全く関係のないところに影響が出る可能性がある** ということです。

先のグローバル変数の例に「いつ変更されるかがわからない」というものがありましたが、これというのはまさに副作用があるからこそ起こる問題です。

副作用マシマシなコードというのは、一言で言えば **「何が起こるかわからないコード」** とも言えます。  
安全でバグのないコードを書きたいのに、エンジニア自身が把握できないコードがプロジェクトに眠っている状態というのは、まさに **恐怖** です。  
そのため、なんとかしてこの副作用となんとかして付き合っていく必要があるわけですね。

では、どのようにすればよいのでしょうか。

### 変数を使わない

そもそも、**変数** というものがあるから副作用が起こるわけですので、その原因である **変数を使わなければ副作用を抑えることができます。**

変数以外にも副作用は存在するのですが、まずは最も身近な副作用から順番に潰していきましょう、それからでも話は遅くありません。

### 変数を「管理」する

## 単一責任原則

### 結論

- **単一責任原則に則ったコードは理解しやすい。**

（執筆中）
