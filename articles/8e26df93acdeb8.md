---
title: "ソフトウェアの品質定義と技術的な意思決定のすゝめ"
emoji: ""
publication_name: "wizleap_tech"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["品質", "意思決定"]
published: false
---

## はじめに

エンジニアの究極的な目標は、**高品質なソフトウェアを開発・保守・運用すること**です。  
エンジニアが行うすべての意思決定は、この目標に紐づいていなければなりませんが、そもそも **「高品質」** とは一体何を指すのでしょうか？

それはソフトウェアの使いやすさでしょうか？  
パフォーマンスの良さでしょうか？  
はたまた、コードの読みやすさでしょうか？
逆に、これらが満たされていればソフトウェアは高品質と言えるのでしょうか？

また、エンジニアはこの目標を達成するために技術的な意思決定を行いますが、その意思決定がプロダクトにどのようなインパクトを与え、またそれを技術に詳しくない人にも伝え、理解を得ることができるでしょうか？

本記事では、バートランド・メイヤー著の『オブジェクト指向入門 第 2 版 原則・コンセプト』を参考に、私見を交えつつソフトウェアの品質について確認し、どのように適切な技術的意思決定を遂行するかを考察します。

読者にはエンジニアを想定しており、ある程度ソフトウェア、特に Web アプリケーションの開発経験があることを想定していますが、技術に詳しくない方でも理解しやすいように心がけています（技術的な話題は流していただいても全体像を把握できるように書いております）。

本記事は以下のような問題を抱えている方を想定しています。

- 技術的な意思決定がどのようにソフトウェアに貢献するのかを考えたい
- 技術的な意思決定について Biz サイドから理解が得られない
- 毎回無理なスケジュールでの開発を強いられ、疲弊している
- エンジニアとのコミュニケーションが上手く取れない
- など

また、この記事は「自社開発を行う会社のエンジニア」の立場で書かれておりますので、受託開発での視点では書かれていないことにご留意ください。

## 外部品質と内部品質

ソフトウェアの品質は、**外部品質**と**内部品質**の 2 つに分類されます。

外部品質は、**ユーザーが直接認識できる品質**を指します。  
例えば、ソフトウェアがバグなく動くことや、UI/UX が使いやすいこと、パフォーマンスが良いことなどが外部品質に含まれます。

一方、内部品質は**ユーザーが認識できない品質**を指します。言い換えれば、ソースコードにアクセスできるエンジニアのための品質と言って差し支えありません。  
コードの可読性の高さ、オブジェクト指向や関数型プログラミングといったパラダイムの原則に従っているかなどの、エンジニアにとって重要な項目が内部品質に含まれます。

この 2 つの違いは、「ユーザーが認識できる品質かどうか」になりますが、ここでの「ユーザー」とは、**ソフトウェアに関わる全ての人**を指しています。  
つまり、ソフトウェアの利用者だけでなく、ソフトウェアを契約する役員、そのソフトウェアの営業をする人、ソフトウェアの仕様を考える人なども含まれるため、通常使われる言葉より意味が広いことに注意が必要です（以下、「ユーザー」という言葉はこの定義で扱い、ソフトウェアの利用者を「エンドユーザー」と呼びます）。

さて、ソフトウェアにとってどちらも重要な品質ではありますが、最終的に問題になるのは**外部品質**です。  
どんなにコードが正しく管理されていたとしても、ユーザーにとって使いにくかったり、パフォーマンスやセキュリティ上の問題があれば、そのソフトウェアは高品質とは言えません。  
また逆に、多少コードに難があったとしても、ユーザーに致命的な問題が発生することに比べれば、それがより大きな問題になることはないでしょう。  
これらのことから、**外部品質は内部品質よりも常に優位にあり、すべての技術的な意思決定は、外部品質を向上させるために行われなければならない**と言えます。

しかし、だからといって内部品質をおざなりにして良いわけではありません。  
むしろ、**外部品質の成功の鍵は、内部品質にあります。**  
外部品質に紐づくであろう内部品質に関する意思決定の連続が、高品質なソフトウェアを生み出す基盤となります。  
そのため、高い外部品質を生み出すためにエンジニアがまず取り組むことは、**外部品質そのものを理解すること**です。  
技術的なあれこれについて思考を巡らすことももちろん重要ですが、その技術がどのような形で外部品質に影響するのかを考察するためにも、外部品質の理解は必要となります。

## 主要な外部品質の要因

『オブジェクト指向入門 第 2 版 原則・コンセプト』では 14 の外部品質要因について紹介されています。  
以下は各品質を私の言葉で端的にまとめたものです。

| 要因           | 要約                                                                         |
| -------------- | ---------------------------------------------------------------------------- |
| **正確さ**     | ソフトウェアは仕様通りに正しく動かなければならない                           |
| **頑丈さ**     | 意図しない挙動をしても、ソフトウェアは壊れず正しく終了し、通知する必要がある |
| **拡張性**     | 仕様変更のしやすさ                                                           |
| **再利用性**   | ソフトウェアのパターンを発見し、再利用する                                   |
| **互換性**     | 他のソフトウェアとの組み合わせやすさ                                         |
| **効率性**     | パフォーマンスの良さ                                                         |
| **可搬性**     | 移植しやすいインフラ                                                         |
| **使いやすさ** | 優れた UI/UX                                                                 |
| **機能性**     | ソフトウェアができることの範囲                                               |
| **適時性**     | リリースの速度                                                               |
| **実証性**     | QA のしやすさ                                                                |
| **統合性**     | セキュリティの堅牢さ                                                         |
| **修復性**     | インシデントが発生したときのリカバーの速さ                                   |
| **経済性**     | 金銭的な運用コスト                                                           |

ここでは上記からいくつかをピックアップし、各外部品質と内部品質の関係について、例を出しつつお話いたします。

### 正確さ

> 正確さとは仕様によって定義されているとおりに仕事を実行するソフトウェア製品の能力である。  
> （引用: バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』 p4）

**これは外部品質の中で最も重要な項目といっても過言ではありません。**  
ソフトウェアは正しく動くことが絶対条件です。正しく動かないソフトウェアを意図して作る理由も、それをリリースする理由もありません。  
そのため、エンジニアはこの正確さを達成することを第一の目標として行動する必要があります。

#### ドメインモデリング

ソフトウェアを作るためには、要求や要件をプログラムで表現することになりますが、しかしながら、そもそもこのハードル自体が非常に高いものとなっています。  
というのも、コーディングはもちろんのこと、要求や要件の理解やシステムデザインなども行うため、単純なプログラミングの能力だけではなく、コミュニケーション能力やドメイン知識、設計の能力も必要となるからです。

こうした問題に立ち向かうための方法論として有名なのが、**ドメイン駆動設計（DDD）** です。  
DDD は、ソフトウェアを作る際に、そのソフトウェアが扱うドメイン（業務領域）をモデリングし、それをプログラムに落とし込む設計手法です。  
DDD を導入する理由の一つとして、**ソースコードによってドメインを表現し、ソフトウェアが正確に動くこと（ドメインに適合すること）を保証しようとする**といったものがあります（もちろん他の理由もございますが、そちらは後述いたします）。  
もちろん DDD を導入しなければ正確さを保証できないというわけではありません。  
重要なのは、**プロダクトの段階や要求を踏まえて適切に意思決定を行うこと**ですので、DDD はその**手段**としてあるということを忘れてはいけません。

#### 前提条件依存による正確さ保証

そうした開発の困難を経た次には、本当に開発したものが正しく動くか検証する作業がありますが、これにも困難が伴います。  
どんなに QA を頑張ったとしても、ソフトウェアを作るのが人間である以上、完全にバグを排除することはほぼ不可能といってよいでしょう。

では、そうした困難の中でどのようにして正確さを保証すればよいのかというと、基本的には**前提条件依存**によって行われます。  
つまり、ソフトウェアという大きな単位だけを見て正確さを保証しようとするのではなく、**ソフトウェアを構成する個々の層の中で正しく動くことを保証し、その信頼の上で別の層を依存させる**という方法が取られます。

例えば、Web アプリケーションがどのような依存関係になっているのかを図を交えながら考えてみましょう。

```mermaid
graph TB
  AWS
  ServerApplication["サーバーアプリケーション"]
  ServerLanguage["プログラミング言語"]
  CompilerOrInterpreter["コンパイラ/インタプリタ"]
  ServerOS["サーバーOS"]
  ServerMachine["サーバー"]

  ServerApplication --> ServerLanguage --> CompilerOrInterpreter --> ServerOS --> ServerMachine --> AWS
```

上記の図は、Web アプリケーションのサーバーサイドがどのような依存関係になっているかを簡単に示しています。矢印が依存関係、矢印の先が依存される側を表しています。

サーバーアプリケーションを作るためにはプログラミング言語を使いますが、そのためにはプログラミング言語が正しく機能している必要があります。  
しかし我々がプログラムを書くとき、プログラミング言語が正しく機能するかどうかを確認することはほぼありません。つまり、そこではプログラミング言語が正しく動くことを前提としてアプリケーションが構築されているということです。

一方プログラミング言語側では、何かしらの方法を用いて自分自身が正しく動くことを保証していると思いますが、しかしプログラミング言語が正しく動くためには、コンパイラやインタプリタが正しく機能することが必要となり……といった具合に、依存先が正しく動くことを前提として、各層の依存関係は構築されているわけです。

もう少し具体的に、サーバーアプリケーションの中でどのような依存関係があるのかを考えてみましょう。

```mermaid
graph TB
  subgraph ServerApplication["サーバーアプリケーション"]
    direction TB
    subgraph Domain
      ValueObject
      Entity["Entity etc."]
    end
    subgraph Application
      UseCase["UseCase etc."]
    end
    subgraph Adapter
      Controller["Controller etc."]
    end

    Adapter --> Application --> Domain
  end

  ServerApplication --> ServerLanguage["プログラミング言語"]
```

これは DDD + Clean Architecture の設計を簡易的に表現したものです。  
コードレベルでも前提条件依存は存在しており、例えば UseCase にてロジックを記述する際は、ValueObject や Entity が正しく動くことを前提としています。  
そして、それぞれの層が正しく動くことを保証する手段として、我々はよく**テストコード**を書きます。  
つまり、テストコードによって層の中の各モジュールが正しく動くことを保証しつつ、モジュールの利用者視点では、それらが正しく動くことを信頼して依存するという連鎖によってコーディングを行っているわけです。

ここまでを踏まえると、**Clean Architecture やテストコードというのは、この前提条件依存を実現するための手段（=内部品質）であり、その効果として正確に動作するソフトウェアを実現できる**というのが見えてくると思います。

#### 正確さ - まとめ

- 正確さとは、**仕様通りにソフトウェアが動く能力である。**
- 正確さを保証するためには、要求をプログラムで正しく表現する**ドメインモデリング**という視点と、ソフトウェアを構成する個々の層の中で正しく動くことを保証し、その信頼の上で別の層を依存させる**前提条件依存**という視点が重要である。
- 正確さを保証する内部品質の手段として、**DDD**や**Clean Architecture**、**テストコード**などがある。

### 拡張性

> 拡張性とは仕様の変更に対するソフトウェア製品の適用のしやすさである。  
> （引用: バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』 p7）

ソフトウェアの「ソフト」とは、ハードウェアと比べて変更が容易（ソフト）であることを指していますが、ソフトウェアの規模が大きくなると、その変更が困難になることがあります。  
ドメインは時間とともに変化するものでありますから、変化について行けないソフトウェアを作ってしまうと、改修に本来不必要なコストが掛かってしまったり、最悪の場合、ソフトウェア自体を作り直す必要が出てきてしまうこともあります。

この本では拡張性を向上させるための原則として、**設計の単純さ**と**非集中化**の 2 つが挙げられています。

> - **設計の単純さ（design simplicity）**: 単純なアーキテクチャは常に複雑なアーキテクチャよりも変更に適応しやすい。
> - **非集中化（decentralization）**: モジュールの自治性が高まるほど、単純な変更が与える影響が１つまたは少数のモジュールにとどまる可能性が高く、システム全体に及ぶ変更の連鎖反応を起こさない。
>
> （引用: バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』 p8）

前者について、状況によっては複雑なものを導入しなければならないときもありますが、できるだけシンプルなアーキテクチャを選択できたほうが学習コストも下げられ、変更しやすいというのは想像できます。  
また後者については、単一責任の原則（SRP）にもあるとおりなので、こちらは言わずもがなと思います。

#### 再びドメインモデリング

正確さ保証の手段として DDD を例として挙げておりましたが、拡張性を担保する手段としても DDD は有効です。  
DDD では現実世界の問題（ドメイン）を何らかの方法でモデリングし抽象を作ろうとしますが、それが何を意味するのかというと、一言で言えば **モデルを用いたドメインとの対応付け** です。

```mermaid
flowchart TB
  subgraph World["世界"]
    Domain["カオティックな現実の問題（ドメイン）"]
  end

  subgraph Model["モデル"]
    direction BT
    subgraph Entity
    end
    subgraph ValueObject
    end
  end

  World --"モデリング"--> Model
```

ドメインは時間とともに変化するわけですが、もちろんその際にモデルも更新する必要があります。  
もしコードでモデリングを行い、それがドメインとの対応が取れていたならば、ドメインの変化のとおりにコードを変更すれば良いので、技術的な観点でコードを変更するのではなく、**Domain-Driven で** コードを変更でき、それが結果的に拡張性を担保することになります（詳しくは改めて記事を執筆する予定です）。

#### 拡張性 - まとめ

- 拡張性とは、**仕様の変更に対するソフトウェア製品の適用のしやすさである。**
- 拡張性を向上させるためには、**設計の単純さ** と **非集中化（≒ 単一責任）** が重要である。
- 拡張性を担保する手段の 1 つとして、**DDD**が有効である。

### 再利用性

> 再利用性とは多数多彩なアプリケーションの構築に使うことのできる、ソフトウェア要素の能力である。  
> （引用: バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』 p8）

上の引用は少しわかりにくいですが、端的に言えば **「共通するパターンを把握し、複数の開発で再利用する能力」** です。  
再利用ができれば、過去に遭遇した問題の解決方法を再度考える必要がなくなり、他の多くの外部品質にも影響を与えることができます。  
例えば、書くコードの量が減らせますので、開発の工数が減り、他の要素の向上に割くことができるようになります。  
また、コードの量が減ることは、内部の複雑さを抑えられるという面もあるため、正確さや拡張性といった外部品質にも貢献することになるでしょう。

#### ライブラリの活用・作成

再利用性を高める技術的なアプローチとして、**オブジェクト指向**や**デザインパターン**といったものもございますが、ここでは **ライブラリの活用** についてお話させてください。

例えば、バックエンドの Web アプリケーション開発では、何らかのフレームワークを使うことが多いですが、これも再利用の一種です。  
Web アプリケーションの開発で求められる機能は、どんなプロダクトであっても共通となる要素が多いため、フレームワークの活用は非常に有効です。

また、**自社でライブラリを作成してしまう**というのも一つの方法です。  
例えば弊社のフロントエンドチームでは、Wiz UI という **Vue/React に両対応する独自の UI ライブラリをオープンソースで開発しています**。

[![wiz-ui storybook](/images/wiz-ui/transition.webp)](https://wiz-ui-react.vercel.app/?path=/docs/base-graphs-transition--docs)

https://github.com/Wizleap-Inc/wiz-ui

https://wiz-ui-react.vercel.app/

https://zenn.dev/wizleap_tech/articles/822f99945ae2b6

このライブラリを利用することで、ソフトウェアの開発時に行うスタイリングの工数が激減し、生産性向上に大きく貢献しました。  
また、デザインシステムをライブラリで保証しておりますので、仕様で定義されたデザインとの齟齬なく実装がしやすくなり、正確さの向上にも繋がりました。

このように、ライブラリを活用したり、ときには作成することによって、ソフトウェアの品質を大きく向上できる可能性があります。

#### 再利用性 - まとめ

- 再利用性とは、**共通するパターンを把握し、複数の開発で再利用する能力である。**
- 再利用性を向上させることは、開発工数の削減や内部の複雑さの抑制に繋がり、他の外部品質の向上に貢献する。
- 再利用性を高める技術的なアプローチとして、**オブジェクト指向**や**デザインパターンの活用**、**ライブラリの活用・作成**などがある。

### 効率性

> 効率性とは、処理時間、内部記憶および外部記憶上の空間、通信装置で使用する帯域幅などのハードウェア資源をできる限り必要としないソフトウェアシステムの能力である。  
> （引用: バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』 p10）

定義が少し回りくどいですが、要するに**パフォーマンス**です。  
もちろんパフォーマンスは良いに越したことはありませんが、効率性は他の外部品質とトレードオフの関係になることが多い点に注意が必要です。

#### Rust と効率性

例えば、Rust というプログラミング言語では、**所有権・借用・ライフタイム**といった独自のルールがあります。  
これらのルールにより、ガベージコレクタなしにメモリや並行処理の安全性を保証できるというのが一般的な理解だと思いますが、一方で、これらはビジネスロジックの実装方法にも直接関与するため、常に効率性を意識せざるを得ないという言語設計になっているとも捉えられます。  
ここが面白くも難しいところですが、つまり Rust には**ビジネス要求（概念としての要求）とシステム制約（ハードウェアの特性に関する具体的な要求）を密接に結びつけることができる（結びつけざるを得ない）** という特徴があるということです[^1]。  
これが何を生み出すのかというと、1 つは、コードレベルで抽象的な表現を行っても、所有・借用といったルールやゼロコスト抽象化といった特性により、常に高効率な品質を保証することができるというメリットです。  
その一方で、他の言語よりコードの冗長さや複雑さ、また学習曲線の急峻さが増すといったデメリットが生じます。  
つまり、効率性を向上させるために、他の外部品質――特に、次の章で取り上げる適時性（要するにリリースまでのスピード）の低下といったトレードオフが生じるというわけです（Rust と効率性については別の機会に詳しく考察します）。

[^1]: Rust に限らず、ポインタの利用の明示といった仕組みも効率性の一部と捉えられるので、この特徴が Rust 固有のものではないのですが、ルールとして定義されている分、他言語よりも強調される点において異論はないと思います。

#### 効率性とトレードオフ

先の例の繰り返しになってしまいますが、効率性が他の外部品質とトレードオフになりやすい理由は、**ソフトウェア開発の要求の中に、概念としての要求と、ハードウェアの特性に関する具体的な要求が混在している**からです。  
例えばソフトウェアの仕様に関する要求は前者であり、パフォーマンスはまさに後者に関するものです。  
もし要求が前者のみであれば、ドメインに沿ってソフトウェアを実装すればよいのですが、後者の要求は CPU やメモリといったハードウェアなどの都合を考えながら実装しなければなりません。  
そのためパフォーマンスを向上させるために、ドメイン表現としての正しさを犠牲にして、泥臭い実装を余儀なくされることもあるでしょう。

この章の冒頭でお話した通り、パフォーマンスは良いに越したことはありません。  
しかし、ユーザーの要求以上にパフォーマンスを追求する必要はありません。過剰な効率性への投資を行うのであれば、他の要因にコストを割いたほうがプロダクト全体としては良い結果になるでしょう。  
また、他の要因とトレードオフが無視できないと考えられる場合、要求だからといって盲目的に受け入れるのではなく、本当にそのトレードオフを受け入れてまで実行すべきなのかを、ユーザーと議論することも必要です。

#### 効率性 - まとめ

- 効率性とは、一言でいえば**パフォーマンスの良さ**である。
- 効率性は、ビジネス上の抽象的な要求ではなく、ハードウェアの特性に関する具体的な要求であるため、他の外部品質とトレードオフの関係になりやすい。

### 機能性/適時性

> 機能性とは、そのシステムが提供できるサービスの範囲である。  
> （引用: バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』 p15）

> 適時性とはユーザが必要としているとき、または、必要とする前にソフトウェアシステムをリリースできることである。  
> （引用: バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』 p15）

この 2 つを端的に表現するならば、 **「もっといろいろな機能を開発してほしい」「もっと早くリリースしてほしい」** という要求に答える能力です。  
これらをまとめて取り上げたのには理由があり、これはどちらも**プロジェクトに対してかかる圧力となるから**です。  
ここからは実際に弊社で発生した問題を取り上げて見ましょう。

#### 少ない人数で大きな開発を 3 つほぼ同時に行った話

これはメインのプロダクトの開発を行うエンジニアが 5 人ほどだった頃のお話です。  
その時は時期が悪く、いろいろな要求や要件がいくつか重なってしまい、**「3 人ほどリソースを投下して 2, 3 ヶ月くらいかかる大きな開発」** を **「3 つほぼ同時」** かつ **「半年以内のリリース」** を余儀なくされたことがありました。  
さらにこの開発だけを行っていればよいわけではなく、随時発生するソフトウェアの改修やバグフィックス、他プロダクトの開発を行いつつ、また当時 QA 組織が存在しなかったため、リリースが近くなるとエンジニアが開発の手を止めてシステムテストも行うという状況でした。  
どう考えても人数が足りないのですが、会社として大きなターニングポイントになるところだったので、エンジニア全員で血反吐を吐きながらなんとかリリース **は** 達成できました。

**※ この件でエンジニア全員が懲りたので、もうこんな開発体制にはなっておりません！　平和に開発しております！**

#### リリース後、どうなったか

確かに、エンジニアは早く、そして多くの機能をリリースできました。しかしその結果はどうだったでしょうか？  
ご想像のとおりだと思いますが、できるだけ内部の品質を落とさないように開発はしていたものの、かなりハードなスケジュールだったため、**一部コードを妥協**していた部分もありますし、**QA 不足によるエラー**や、**そもそも要求・要件が練られておらず、リリース後に仕様漏れが発覚**するといった問題も起こりました。  
結果的にプロダクトは良い方向に進んだので、そこだけを見れば成功と言えるのかもしれませんが、毎回こんなことをしていてはエンジニアは疲弊しますし、ソフトウェアの品質も維持できているとは到底言えません。

#### 何が問題だったのか

これらの問題の根本は、**機能性と適時性を追求しすぎた**ことにあります。  
冒頭でこの 2 つは圧力として大きくかかるとお話しましたが、その理由は端的にいってしまえば、**利益になりやすいから**です。

新しい機能をリリースできれば、ユーザーの要望をより多く叶えられる。  
早くリリースできれば、ユーザーの要望を早く叶えられる。

もちろんこんな単純ではありませんし、プロダクトにも依るのですが、経営者やプロダクトマネージャーにとって、この 2 つは魅力的に映ることが多いのです。

しかしながら上記の例のように、過剰に追求することは、他の外部品質に大きな影響を与えることになります。  
先のソフトウェアは結果として、拡張性や効率性ももちろんそうですし、なにより最も死守しなければならない**正確さ**を失うことになりました。

では、どうすればよかったのでしょうか？  
次の章から考えていきましょう。

#### 機能性/適時性 - まとめ

- 機能性とは、**そのシステムが提供できるサービスの範囲**である。
- 適時性とは、**ユーザが必要としているとき、または、必要とする前にサービスをリリースできる能力**である。
- 機能性と適時性は、プロジェクトに対してかかる圧力となることが多く、他の外部品質とトレードオフの関係になりやすい。

## ソフトウェアの高品質を定義する

ここまで様々な外部品質や、それらのトレードオフについて考えてきました。  
今度はこれらの品質を踏まえたうえで、どのように活用していけばよいのかを考えていきましょう。

### 各品質のトレードオフを考え、明確にする

プロダクトの段階や性質によって、求められる外部品質は大きく異なります。  
そのため、現段階のプロダクトに求められる外部品質を明確にし、それに対してどの品質をどの程度追求するかを考えることが重要です。

これを大まかに把握する手法として、アジャイル開発ではおなじみ **トレードオフ・スライダー** というものがあります。  
例えば、「リリース最優先・最低限動くものを最速で作る段階のプロダクト」を可視化すると、おおよそ以下のようになると思います。

![trade_off_slider_1](/images/agile/trade_off_slider_1.webp)

このグラフがあれば、チーム全体で何が重要で、何を犠牲にしているのかを一発で把握することができます。

これまでの考察を踏まえると、トレードオフ・スライダーは、**主要な外部品質のトレードオフを可視化し、チーム全体で共有するもの**と解釈することができます。  
基本の項目である「スコープ」「予算」「スケジュール」「品質」を外部品質に落とし込むと、**「機能性」「経済性」「適時性」「正確さ、使いやすさ、効率性、etc.」** といった要素になります。  
もちろん、これら以外の項目でチームにとって重要な項目もあるでしょう。そうしたものを話し合って、スライダーに反映させるのも良いでしょう。

![trade_off_slider_2](/images/agile/trade_off_slider_2.webp)

### 技術的な意思決定が、品質に与える影響を説明する

要求を過不足なく実現

なぜやるのかの共通の認識を持つために、言語化しよう

その際に、内部品質について詳しく説明する必要はない

実現不可能な要求には、NO という勇気も

## おわりに

ソフトウェアはエンジニアだけで作れるものではありません。  
プロダクトマネージャーやデザイナー、営業、マーケティング、カスタマーサポート、そして何よりエンドユーザーとともに作り上げるものです。

一方で、エンジニアはソフトウェア開発の奴隷ではありません。エンジニアも立派なユーザーの一人なのです。  
だから我々は、ソフトウェアに関わる 1 人のユーザーとして、よりソフトウェアに問いかけても良いと思いますし、またそういった組織を作っていきたいとも思うのです。

## 参考

- バートランド・メイヤー『オブジェクト指向入門 第 2 版 原則・コンセプト』、酒匂 寛 訳、翔泳社
